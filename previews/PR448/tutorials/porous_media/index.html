<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Porous media · Ferrite.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://ferrite-fem.github.io/Ferrite.jl/stable/tutorials/porous_media/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Ferrite.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Ferrite.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../">Tutorials overview</a></li><li><a class="tocitem" href="../heat_equation/">Heat Equation</a></li><li><a class="tocitem" href="../postprocessing/">Postprocessing</a></li><li><a class="tocitem" href="../helmholtz/">Helmholtz equation</a></li><li><a class="tocitem" href="../incompressible_elasticity/">Incompressible Elasticity</a></li><li><a class="tocitem" href="../hyperelasticity/">Hyperelasticity</a></li><li><a class="tocitem" href="../threaded_assembly/">Threaded Assembly</a></li><li><a class="tocitem" href="../plasticity/">von Mises plasticity</a></li><li><a class="tocitem" href="../transient_heat_equation/">Time Dependent Problems</a></li><li><a class="tocitem" href="../landau/">Ginzburg-Landau model energy minimization</a></li><li><a class="tocitem" href="../linear_shell/">Linear shell</a></li><li><a class="tocitem" href="../quasi_incompressible_hyperelasticity/">Nearly Incompressible Hyperelasticity</a></li><li><a class="tocitem" href="../ns_vs_diffeq/">Incompressible Navier-Stokes Equations via DifferentialEquations.jl</a></li><li><a class="tocitem" href="../computational_homogenization/">Computational homogenization</a></li><li><a class="tocitem" href="../stokes-flow/">Stokes flow</a></li><li><a class="tocitem" href="../topology_optimization/">Topology optimization</a></li><li class="is-active"><a class="tocitem" href>Porous media</a><ul class="internal"><li><a class="tocitem" href="#Theory-of-porous-media"><span>Theory of porous media</span></a></li><li><a class="tocitem" href="#Implementation"><span>Implementation</span></a></li><li><a class="tocitem" href="#porous-media-plain-program"><span>Plain program</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Topic guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../topics/">Topic guide overview</a></li><li><a class="tocitem" href="../../topics/fe_intro/">Introduction to FEM</a></li><li><a class="tocitem" href="../../topics/degrees_of_freedom/">Degrees of Freedom</a></li><li><a class="tocitem" href="../../topics/assembly/">Assembly</a></li><li><a class="tocitem" href="../../topics/boundary_conditions/">Initial and Boundary Conditions</a></li><li><a class="tocitem" href="../../topics/constraints/">Constraints</a></li><li><a class="tocitem" href="../../topics/grid/">Grid</a></li><li><a class="tocitem" href="../../topics/export/">Export</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../reference/">Reference overview</a></li><li><a class="tocitem" href="../../reference/quadrature/">Quadrature</a></li><li><a class="tocitem" href="../../reference/interpolations/">Interpolation</a></li><li><a class="tocitem" href="../../reference/fevalues/">FEValues</a></li><li><a class="tocitem" href="../../reference/dofhandler/">Degrees of Freedom</a></li><li><a class="tocitem" href="../../reference/assembly/">Assembly</a></li><li><a class="tocitem" href="../../reference/boundary_conditions/">Boundary Conditions</a></li><li><a class="tocitem" href="../../reference/grid/">Grid &amp; AbstractGrid</a></li><li><a class="tocitem" href="../../reference/export/">Postprocessing</a></li><li><a class="tocitem" href="../../reference/utils/">Development utility functions</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">How-to guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../howto/">How-to guide overview</a></li></ul></li><li><a class="tocitem" href="../../devdocs/">Developer documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Porous media</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Porous media</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/docs/src/literate/porous_media.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Porous-media"><a class="docs-heading-anchor" href="#Porous-media">Porous media</a><a id="Porous-media-1"></a><a class="docs-heading-anchor-permalink" href="#Porous-media" title="Permalink"></a></h1><p>Porous media is a two-phase material, consisting of solid parts and a liquid occupying the pores inbetween. Using the porous media theory, we can model such a material without explicitly resolving the microstructure, but by considering the interactions between the solid and liquid. In this example, we will additionally consider larger linear elastic solid aggregates that are impermeable. Hence, there is no liquids in these particles and the only unknown variable is the displacement field <code>:u</code>. In the porous media, denoted the matrix, we have both the displacement field, <code>:u</code>, as well as the liquid pressure, <code>:p</code>, as unknown. The computational domain is shown below</p><p><img src="porous_media.svg" alt="Computational domain"/> <img src="../porous_media.gif" alt="Pressure evolution."/></p><h2 id="Theory-of-porous-media"><a class="docs-heading-anchor" href="#Theory-of-porous-media">Theory of porous media</a><a id="Theory-of-porous-media-1"></a><a class="docs-heading-anchor-permalink" href="#Theory-of-porous-media" title="Permalink"></a></h2><p>The strong forms for the mass balance of the liquid is given as</p><p class="math-container">\[   \frac{\mathrm{d}_\mathrm{s} n \rho_\mathrm{l}}{\mathrm{d}t}
   + \mathrm{div}\left(n \rho_\mathrm{l} \tilde{\boldsymbol{v}}_\mathrm{l}\right)
   + n \rho_\mathrm{l} \mathrm{tr}(\boldsymbol{\dot{\epsilon}}) = 0\]</p><p>where <span>$\mathrm{d}_\mathrm{s}/\mathrm{d}t$</span> is the time of a quantity following the solid skeleton motion, described by the displacements <span>$\boldsymbol{u}$</span>. <span>$n$</span> is the porosity (i.e. volume fraction of pores, assumed constant due to small strains), <span>$\rho_\mathrm{l}$</span> is the liquid density, <span>$\tilde{\boldsymbol{v}}_\mathrm{l}$</span> is the liquid velocity relative to the solid skeleton motion, and <span>$\boldsymbol{\epsilon}$</span> is the strain tensor for the solid skeleton, <span>$\boldsymbol{\epsilon}=\left[\mathrm{grad}(\boldsymbol{u})\right]^\mathrm{sym}$</span>. The functions <span>$\mathrm{div}()$</span> and <span>$\mathrm{grad}()$</span> represent the divergence and gradient, respectively. Furthermore, the balance of momentum is given as</p><p class="math-container">\[   \mathrm{div}(\boldsymbol{\sigma}) = \boldsymbol{0}\]</p><p>where <span>$\boldsymbol{\sigma}$</span> is the Cauchy stress. For simplicity in this example, body loads, e.g. due to gravity, are not included.</p><h3 id="Constitutive-equations"><a class="docs-heading-anchor" href="#Constitutive-equations">Constitutive equations</a><a id="Constitutive-equations-1"></a><a class="docs-heading-anchor-permalink" href="#Constitutive-equations" title="Permalink"></a></h3><p>Darcy&#39;s law, excluding gravity loads, is used for the fluid flow through the porous media</p><p class="math-container">\[   n \tilde{\boldsymbol{v}}_\mathrm{l} = -[k/\mu] \mathrm{grad}(p)\]</p><p>A constant fluid bulk modulus, <span>$K_\mathrm{l}$</span>, gives the relationship between fluid pressure, <span>$p$</span>, and density, <span>$\rho_\mathrm{l}$</span>, as</p><p class="math-container">\[\dot{\rho}_\mathrm{l} = \frac{\rho_\mathrm{l}}{K_\mathrm{l}} \dot{p}\]</p><p>Finally, we use the most simple Terzaghi effective stress combined with linear isotropic elasticity</p><p class="math-container">\[\boldsymbol{\sigma} = \boldsymbol{\mathrm{E}}:\boldsymbol{\epsilon} - p\boldsymbol{I} = 2G \boldsymbol{\epsilon}^\mathrm{dev} + 3 K \boldsymbol{\epsilon}^\mathrm{vol} - p \boldsymbol{I}\]</p><h3 id="Weak-form"><a class="docs-heading-anchor" href="#Weak-form">Weak form</a><a id="Weak-form-1"></a><a class="docs-heading-anchor-permalink" href="#Weak-form" title="Permalink"></a></h3><p>From the above strong form with constitutive equations (and including boundary conditions), we obtain the following weak forms for the mass balance,</p><p class="math-container">\[  \int_\Gamma \delta p \tilde{\boldsymbol{v}}_\mathrm{l} \cdot \boldsymbol{n} \mathrm{d}\Gamma =
  \int_\Omega \mathrm{grad}(\delta p) \cdot \mathrm{grad}(p) [k/n] \mathrm{d} \Omega +
  \int_\Omega \delta p \left[\dot{p}/K_\mathrm{l} + \mathrm{div}\left(\dot{\boldsymbol{u}}\right)\right] \mathrm{d}\Omega\]</p><p>and for the momentum balance</p><p class="math-container">\[  \int_\Gamma \boldsymbol{\delta u} \cdot \boldsymbol{t} \mathrm{d} \Gamma =
  \int_\Omega \mathrm{grad}\left(\boldsymbol{\delta u}\right) : \left[ \boldsymbol{\mathrm{E}} : \mathrm{grad}(\boldsymbol{u}) - p \boldsymbol{I}\right] \mathrm{d} \Omega\]</p><h3 id="Finite-element-form"><a class="docs-heading-anchor" href="#Finite-element-form">Finite element form</a><a id="Finite-element-form-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-element-form" title="Permalink"></a></h3><p>Discretizing in space using finite elements, we obtain the matrix equation <span>$f_{i}^\mathrm{ext}=K_{ij} a_j + L_{ij} \dot{a}_j$</span> where <span>$f^\mathrm{ext}$</span> are the external &quot;forces&quot;, <span>$K$</span> the stiffness matrix, <span>$a$</span> the unknown degrees of freedom, <span>$L$</span> the (dampening) matrix that is multiplied with the rate of the unknown degrees of freedom. For each relevant part, we can specify these matrices and vectors as</p><p class="math-container">\[\begin{align*}
   K_{ij}^\mathrm{pp} &amp;= \int_\Omega \mathrm{grad}\left(\delta N^\mathrm{p}_i\right)\cdot \left[\frac{k}{n}\mathrm{grad}\left(N^\mathrm{p}_j\right)\right] \mathrm{d}\Omega \\
   L_{ij}^\mathrm{pp} &amp;= \int_\Omega \delta N_i^\mathrm{p} N_j^\mathrm{p}/K_\mathrm{l} \mathrm{d}\Omega \\
   L_{ij}^\mathrm{pu} &amp;= \int_\Omega \delta N_i^\mathrm{p} \mathrm{div}\left(\boldsymbol{N}_j^\mathrm{u}\right) \mathrm{d}\Omega \\
   K_{ij}^\mathrm{uu} &amp;= - \int_\Omega \mathrm{grad}\left(\boldsymbol{\delta N}^\mathrm{u}_i\right) : \boldsymbol{\mathrm{E}} : \mathrm{grad}\left(\boldsymbol{N}_j^\mathrm{u}\right) \mathrm{d} \Omega \\
   K_{ij}^\mathrm{up} &amp;= \int_\Omega \mathrm{div}\left(\boldsymbol{\delta N}_i^\mathrm{u}\right) N_j^\mathrm{p} \mathrm{d}\Omega \\
   f_{i}^\mathrm{p,ext} &amp;= \int_\Gamma \delta N_i^\mathrm{p} \tilde{\boldsymbol{v}}_\mathrm{l} \cdot \boldsymbol{n} \mathrm{d}\Gamma\\
   f_{i}^\mathrm{u,ext} &amp;= -\int_\Gamma \boldsymbol{\delta N}_i^\mathrm{u} \cdot \boldsymbol{t} \mathrm{d} \Gamma
\end{align*}\]</p><p>This results in the equation system</p><p class="math-container">\[\begin{align*}
f_{i}^\mathrm{p,ext} &amp;= K_{ij}^\mathrm{pp} a_{j}^\mathrm{p} + L_{ij}^\mathrm{pp} \dot{a}_j^\mathrm{p} + L_{ij}^\mathrm{pu} \dot{a}_j^\mathrm{u} \\
f_{j}^\mathrm{u,ext} &amp;= K_{ij}^\mathrm{up} a_{j}^\mathrm{p} + K_{ij}^\mathrm{uu} a_j^\mathrm{u}
\end{align*}\]</p><p>where the subscripts <span>$\mathrm{p}$</span> and <span>$\mathrm{u}$</span> gives the part of the vector pertinent to that degree of freedom (pressure or displacement). The time discretized form of the above equation becomes</p><p class="math-container">\[\begin{align*}
\Delta t f_{i}^\mathrm{p,ext} + L_{ij}^\mathrm{pp} a_j^\mathrm{p,old} + L_{ij}^\mathrm{pu} a_j^\mathrm{u,old} &amp;= \Delta t K_{ij}^\mathrm{pp} a_{j}^\mathrm{p} + L_{ij}^\mathrm{pp} a_j^\mathrm{p} + L_{ij}^\mathrm{pu} a_j^\mathrm{u} \\
f_{j}^\mathrm{u,ext} &amp;= K_{ij}^\mathrm{up} a_{j}^\mathrm{p} + K_{ij}^\mathrm{uu} a_j^\mathrm{u}
\end{align*}\]</p><p>As the matrices are constant, it suffices to assemble them once and reuse for each time step. However, in this example we assemble in each time step, calculating only one stiffness matrix. The contributions from the old values, on the left hand side, are considered as external loads. This avoids having two global matrices, simplifying the present example and making it more suitable to consider nonlinear problems. With all the theory completed, let&#39;s start implementing a solution to this problem in Ferrite. Material parameters are hard-coded in for simplicity.</p><h2 id="Implementation"><a class="docs-heading-anchor" href="#Implementation">Implementation</a><a id="Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation" title="Permalink"></a></h2><p>We now solve the problem step by step. The full program with fewer comments is found in the final <a href="#porous-media-plain-program">section</a></p><p>Required packages</p><pre><code class="language-julia hljs">using Ferrite, FerriteMeshParser, Tensors</code></pre><h3 id="Elasticity"><a class="docs-heading-anchor" href="#Elasticity">Elasticity</a><a id="Elasticity-1"></a><a class="docs-heading-anchor-permalink" href="#Elasticity" title="Permalink"></a></h3><p>We start by defining the elastic material type, containing the elastic stiffness, for the linear elastic impermeable solid aggregates.</p><pre><code class="language-julia hljs">struct Elastic{T}
    C::SymmetricTensor{4,2,T,9}
end
function Elastic(;E=20.e3, ν=0.3)
    G = E / 2(1 + ν)
    K = E / 3(1 - 2ν)
    I2 = one(SymmetricTensor{2,2})
    I4vol = I2⊗I2
    I4dev = minorsymmetric(otimesu(I2,I2)) - I4vol / 3
    return Elastic(2G*I4dev + K*I4vol)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.Elastic</code></pre><p>Next, we define the element routine for the solid aggregates, where we dispatch on the <code>Elastic</code> material struct. Note that the unused inputs here are used for the porous matrix below.</p><pre><code class="language-julia hljs">function element_routine!(Ke, fext, material::Elastic, cv, cell, args...)
    reinit!(cv, cell)
    n_basefuncs = getnbasefunctions(cv)
    dσdϵ = material.C
    for q_point in 1:getnquadpoints(cv)
        dΩ = getdetJdV(cv, q_point)
        for i in 1:n_basefuncs
            δ∇N = shape_symmetric_gradient(cv, q_point, i)
            for j in 1:n_basefuncs
                ∇N = shape_symmetric_gradient(cv, q_point, j)
                Ke[i, j] += δ∇N ⊡ dσdϵ ⊡ ∇N * dΩ
            end
        end
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">element_routine! (generic function with 1 method)</code></pre><h3 id="PoroElasticity"><a class="docs-heading-anchor" href="#PoroElasticity">PoroElasticity</a><a id="PoroElasticity-1"></a><a class="docs-heading-anchor-permalink" href="#PoroElasticity" title="Permalink"></a></h3><p>To define the poroelastic material, we re-use the elastic part from above for the skeleton, and add the additional required material parameters.</p><pre><code class="language-julia hljs">struct PoroElastic{T}
    elastic::Elastic{T} ## Skeleton stiffness
    k::T            ## Permeability of liquid   [mm^4/(Ns)]
    ϕ::T            ## Porosity                 [-]
    K_liquid::T     ## Liquid bulk modulus      [MPa]
end
PoroElastic(;elastic, k, ϕ, K_liquid) = PoroElastic(elastic, k, ϕ, K_liquid) # Keyword constructor</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.PoroElastic</code></pre><p>The element routine requires a few more inputs since we have two fields, as well as the dependence on the rates of the displacements and pressure. Again, we dispatch on the material type.</p><pre><code class="language-julia hljs">function element_routine!(Ke, fext, m::PoroElastic, cvs::Tuple, cell, a_old, Δt, sdh)
    # Setup cellvalues and give easier names
    reinit!.(cvs, (cell,))
    cv_u, cv_p = cvs

    # Check that cellvalues are compatible with each other (should have same quadrature rule)
    @assert getnquadpoints(cv_u) == getnquadpoints(cv_p)

    C_el = m.elastic.C ## Elastic stiffness

    # Assemble stiffness and force vectors
    for q_point in 1:getnquadpoints(cv_u)
        dΩ = getdetJdV(cv_u, q_point)
        # Variation of u_i
        for (iᵤ, Iᵤ) in pairs(dof_range(sdh, :u))
            ∇δNu = shape_symmetric_gradient(cv_u, q_point, iᵤ)
            div_δNu = shape_divergence(cv_u, q_point, iᵤ)
            for (jᵤ, Jᵤ) in pairs(dof_range(sdh, :u))
                ∇Nu = shape_symmetric_gradient(cv_u, q_point, jᵤ)
                Ke[Iᵤ, Jᵤ] -= ∇δNu ⊡ C_el ⊡ ∇Nu * dΩ
            end
            for (jₚ, Jₚ) in pairs(dof_range(sdh, :p))
                Np = shape_value(cv_p, q_point, jₚ)
                Ke[Iᵤ, Jₚ] += div_δNu * Np
            end
        end
        # Variation of p_i
        for (iₚ, Iₚ) in pairs(dof_range(sdh, :p))
            δNp = shape_value(cv_p, q_point, iₚ)
            ∇δNp = shape_gradient(cv_p, q_point, iₚ)
            for (jᵤ, Jᵤ) in pairs(dof_range(sdh, :u))
                div_Nu = shape_divergence(cv_u, q_point, jᵤ)
                Lpu_ij = δNp*div_Nu*dΩ
                Ke[Iₚ,Jᵤ] += Lpu_ij
                fext[Iₚ] += Lpu_ij*a_old[Jᵤ]
            end
            for (jₚ, Jₚ) in pairs(dof_range(sdh, :p))
                ∇Np = shape_gradient(cv_p, q_point, jₚ)
                Np = shape_value(cv_p, q_point, jₚ)
                Kpp_ij = (m.k/m.ϕ) * ∇δNp ⋅ ∇Np * dΩ
                Lpp_ij = δNp*Np/m.K_liquid
                Ke[Iₚ,Jₚ] += Δt*Kpp_ij + Lpp_ij
                fext[Iₚ] += Lpp_ij*a_old[Jₚ]
            end
        end
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">element_routine! (generic function with 2 methods)</code></pre><h3 id="Assembly"><a class="docs-heading-anchor" href="#Assembly">Assembly</a><a id="Assembly-1"></a><a class="docs-heading-anchor-permalink" href="#Assembly" title="Permalink"></a></h3><p>To organize the different domains, we&#39;ll first define a container type</p><pre><code class="language-julia hljs">struct FEDomain{M,CV,SDH&lt;:SubDofHandler}
    material::M
    cellvalues::CV
    sdh::SDH
end</code></pre><p>And then we can loop over a vector of such domains, allowing us to loop over each domain, to assemble the contributions from each cell in that domain (given by the <code>SubDofHandler</code>&#39;s cellset)</p><pre><code class="language-julia hljs">function doassemble!(K, f, domains::Vector{&lt;:FEDomain}, a_old, Δt)
    assembler = start_assemble(K, f)
    for domain in domains
        doassemble!(assembler, domain, a_old, Δt)
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">doassemble! (generic function with 1 method)</code></pre><p>For one domain (corresponding to a specific SubDofHandler), we can then loop over all cells in its cellset. This ensures that the calls to the <code>element_routine</code> are type stable.</p><pre><code class="language-julia hljs">function doassemble!(assembler, domain::FEDomain, a_old, Δt)
    material = domain.material
    cv = domain.cellvalues
    sdh = domain.sdh
    n = ndofs_per_cell(sdh)
    Ke = zeros(n,n)
    fe = zeros(n)
    ae_old = zeros(n)

    for cell in CellIterator(sdh)
        map!(i-&gt;a_old[i], ae_old, celldofs(cell)) # copy values from a_old to ae_old
        fill!(Ke, 0)
        fill!(fe, 0)
        element_routine!(Ke, fe, material, cv, cell, ae_old, Δt, sdh)
        assemble!(assembler, celldofs(cell), Ke, fe)
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">doassemble! (generic function with 2 methods)</code></pre><h3 id="Mesh-import"><a class="docs-heading-anchor" href="#Mesh-import">Mesh import</a><a id="Mesh-import-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-import" title="Permalink"></a></h3><p>In this example, we import the mesh from the Abaqus input file, <a href="../porous_media_0p25.inp"><code>porous_media_0p25.inp</code></a> using <code>FerriteMeshParser</code>&#39;s <code>get_ferrite_grid</code> function. We then create one cellset for each phase (solid and porous) for each element type. These 4 sets will later be used in their own <code>FieldHandler</code></p><pre><code class="language-julia hljs">function get_grid()
    # Import grid from abaqus mesh
    grid = get_ferrite_grid(joinpath(@__DIR__, &quot;porous_media_0p25.inp&quot;))

    # Create cellsets for each fieldhandler
    addcellset!(grid, &quot;solid3&quot;, intersect(getcellset(grid, &quot;solid&quot;), getcellset(grid, &quot;CPS3&quot;)))
    addcellset!(grid, &quot;solid4&quot;, intersect(getcellset(grid, &quot;solid&quot;), getcellset(grid, &quot;CPS4R&quot;)))
    addcellset!(grid, &quot;porous3&quot;, intersect(getcellset(grid, &quot;porous&quot;), getcellset(grid, &quot;CPS3&quot;)))
    addcellset!(grid, &quot;porous4&quot;, intersect(getcellset(grid, &quot;porous&quot;), getcellset(grid, &quot;CPS4R&quot;)))
    return grid
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">get_grid (generic function with 1 method)</code></pre><h3 id="Problem-setup"><a class="docs-heading-anchor" href="#Problem-setup">Problem setup</a><a id="Problem-setup-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-setup" title="Permalink"></a></h3><p>Define the finite element interpolation, integration, and boundary conditions.</p><pre><code class="language-julia hljs">function setup_problem(;t_rise=0.1, p_max=100.0)

    grid = get_grid()

    # Setup the materials
    m_solid = Elastic(;E=20.e3, ν=0.3)
    m_porous = PoroElastic(;elastic=Elastic(;E=10e3, ν=0.3), K_liquid=15e3, k=5.0e-2, ϕ=0.8)

    # Setup the interpolation and integration rules
    dim=Ferrite.getdim(grid)
    ipu_quad = Lagrange{RefQuadrilateral,2}()^2
    ipu_tri  = Lagrange{RefTriangle,2}()^2
    ipp_quad = Lagrange{RefQuadrilateral,1}()
    ipp_tri  = Lagrange{RefTriangle,1}()

    qr_quad = QuadratureRule{RefQuadrilateral}(2)
    qr_tri  = QuadratureRule{RefTriangle}(2)

    # CellValues
    cvu_quad = CellValues(qr_quad, ipu_quad)
    cvu_tri = CellValues(qr_tri, ipu_tri)
    cvp_quad = CellValues(qr_quad, ipp_quad)
    cvp_tri = CellValues(qr_tri, ipp_tri)

    # Setup the DofHandler
    dh = DofHandler(grid)
    # Solid quads
    sdh_solid_quad = SubDofHandler(dh, getcellset(grid,&quot;solid4&quot;))
    add!(sdh_solid_quad, :u, ipu_quad)
    # Solid triangles
    sdh_solid_tri = SubDofHandler(dh, getcellset(grid,&quot;solid3&quot;))
    add!(sdh_solid_tri, :u, ipu_tri)
    # Porous quads
    sdh_porous_quad = SubDofHandler(dh, getcellset(grid, &quot;porous4&quot;))
    add!(sdh_porous_quad, :u, ipu_quad)
    add!(sdh_porous_quad, :p, ipp_quad)
    # Porous triangles
    sdh_porous_tri = SubDofHandler(dh, getcellset(grid, &quot;porous3&quot;))
    add!(sdh_porous_tri, :u, ipu_tri)
    add!(sdh_porous_tri, :p, ipp_tri)

    close!(dh)

    # Setup the domains
    domains = [FEDomain(m_solid, cvu_quad, sdh_solid_quad),
               FEDomain(m_solid, cvu_tri, sdh_solid_tri),
               FEDomain(m_porous, (cvu_quad, cvp_quad), sdh_porous_quad),
               FEDomain(m_porous, (cvu_tri, cvp_tri), sdh_porous_tri)
               ]

    # Add boundary conditions
    ch = ConstraintHandler(dh);
    add!(ch, Dirichlet(:u, getfaceset(grid, &quot;bottom&quot;), (x, t) -&gt; zero(Vec{2}), [1,2]))
    add!(ch, Dirichlet(:p, getfaceset(grid, &quot;bottom_p&quot;), (x, t) -&gt; 0.0))
    add!(ch, Dirichlet(:p, getfaceset(grid, &quot;top_p&quot;), (x, t) -&gt; p_max*clamp(t/t_rise,0,1)))
    close!(ch)

    return dh, ch, domains
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">setup_problem (generic function with 1 method)</code></pre><h3 id="Solving"><a class="docs-heading-anchor" href="#Solving">Solving</a><a id="Solving-1"></a><a class="docs-heading-anchor-permalink" href="#Solving" title="Permalink"></a></h3><p>Given the <code>MixedDofHandler</code>, <code>ConstraintHandler</code>, and <code>CellValues</code>, we can solve the problem by stepping through the time history</p><pre><code class="language-julia hljs">function solve(dh, ch, domains; Δt=0.025, t_total=1.0)
    K = create_sparsity_pattern(dh);
    f = zeros(ndofs(dh))
    a = zeros(ndofs(dh))
    pvd = paraview_collection(&quot;porous_media.pvd&quot;);
    for (step, t) = enumerate(0:Δt:t_total)
        if t&gt;0
            doassemble!(K, f, domains, a, Δt)
            update!(ch, t)
            apply!(K, f, ch)
            a .= K\f
        end
        vtk_grid(&quot;porous_media-$step&quot;, dh) do vtk
            vtk_point_data(vtk, dh, a)
            vtk_save(vtk)
            pvd[step] = vtk
        end
    end
    vtk_save(pvd);
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">solve (generic function with 1 method)</code></pre><p>Finally we call the functions to actually run the code</p><pre><code class="language-julia hljs">dh, ch, domains = setup_problem()
solve(dh, ch, domains)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">42-element Vector{String}:
 &quot;porous_media.pvd&quot;
 &quot;porous_media-1.vtu&quot;
 &quot;porous_media-2.vtu&quot;
 &quot;porous_media-3.vtu&quot;
 &quot;porous_media-4.vtu&quot;
 &quot;porous_media-5.vtu&quot;
 &quot;porous_media-6.vtu&quot;
 &quot;porous_media-7.vtu&quot;
 &quot;porous_media-8.vtu&quot;
 &quot;porous_media-9.vtu&quot;
 ⋮
 &quot;porous_media-33.vtu&quot;
 &quot;porous_media-34.vtu&quot;
 &quot;porous_media-35.vtu&quot;
 &quot;porous_media-36.vtu&quot;
 &quot;porous_media-37.vtu&quot;
 &quot;porous_media-38.vtu&quot;
 &quot;porous_media-39.vtu&quot;
 &quot;porous_media-40.vtu&quot;
 &quot;porous_media-41.vtu&quot;</code></pre><h2 id="porous-media-plain-program"><a class="docs-heading-anchor" href="#porous-media-plain-program">Plain program</a><a id="porous-media-plain-program-1"></a><a class="docs-heading-anchor-permalink" href="#porous-media-plain-program" title="Permalink"></a></h2><p>Here follows a version of the program without any comments. The file is also available here: <a href="../porous_media.jl"><code>porous_media.jl</code></a>.</p><pre><code class="language-julia hljs">using Ferrite, FerriteMeshParser, Tensors

struct Elastic{T}
    C::SymmetricTensor{4,2,T,9}
end
function Elastic(;E=20.e3, ν=0.3)
    G = E / 2(1 + ν)
    K = E / 3(1 - 2ν)
    I2 = one(SymmetricTensor{2,2})
    I4vol = I2⊗I2
    I4dev = minorsymmetric(otimesu(I2,I2)) - I4vol / 3
    return Elastic(2G*I4dev + K*I4vol)
end

function element_routine!(Ke, fext, material::Elastic, cv, cell, args...)
    reinit!(cv, cell)
    n_basefuncs = getnbasefunctions(cv)
    dσdϵ = material.C
    for q_point in 1:getnquadpoints(cv)
        dΩ = getdetJdV(cv, q_point)
        for i in 1:n_basefuncs
            δ∇N = shape_symmetric_gradient(cv, q_point, i)
            for j in 1:n_basefuncs
                ∇N = shape_symmetric_gradient(cv, q_point, j)
                Ke[i, j] += δ∇N ⊡ dσdϵ ⊡ ∇N * dΩ
            end
        end
    end
end

struct PoroElastic{T}
    elastic::Elastic{T} ## Skeleton stiffness
    k::T            ## Permeability of liquid   [mm^4/(Ns)]
    ϕ::T            ## Porosity                 [-]
    K_liquid::T     ## Liquid bulk modulus      [MPa]
end
PoroElastic(;elastic, k, ϕ, K_liquid) = PoroElastic(elastic, k, ϕ, K_liquid) # Keyword constructor

function element_routine!(Ke, fext, m::PoroElastic, cvs::Tuple, cell, a_old, Δt, sdh)
    # Setup cellvalues and give easier names
    reinit!.(cvs, (cell,))
    cv_u, cv_p = cvs

    # Check that cellvalues are compatible with each other (should have same quadrature rule)
    @assert getnquadpoints(cv_u) == getnquadpoints(cv_p)

    C_el = m.elastic.C ## Elastic stiffness

    # Assemble stiffness and force vectors
    for q_point in 1:getnquadpoints(cv_u)
        dΩ = getdetJdV(cv_u, q_point)
        # Variation of u_i
        for (iᵤ, Iᵤ) in pairs(dof_range(sdh, :u))
            ∇δNu = shape_symmetric_gradient(cv_u, q_point, iᵤ)
            div_δNu = shape_divergence(cv_u, q_point, iᵤ)
            for (jᵤ, Jᵤ) in pairs(dof_range(sdh, :u))
                ∇Nu = shape_symmetric_gradient(cv_u, q_point, jᵤ)
                Ke[Iᵤ, Jᵤ] -= ∇δNu ⊡ C_el ⊡ ∇Nu * dΩ
            end
            for (jₚ, Jₚ) in pairs(dof_range(sdh, :p))
                Np = shape_value(cv_p, q_point, jₚ)
                Ke[Iᵤ, Jₚ] += div_δNu * Np
            end
        end
        # Variation of p_i
        for (iₚ, Iₚ) in pairs(dof_range(sdh, :p))
            δNp = shape_value(cv_p, q_point, iₚ)
            ∇δNp = shape_gradient(cv_p, q_point, iₚ)
            for (jᵤ, Jᵤ) in pairs(dof_range(sdh, :u))
                div_Nu = shape_divergence(cv_u, q_point, jᵤ)
                Lpu_ij = δNp*div_Nu*dΩ
                Ke[Iₚ,Jᵤ] += Lpu_ij
                fext[Iₚ] += Lpu_ij*a_old[Jᵤ]
            end
            for (jₚ, Jₚ) in pairs(dof_range(sdh, :p))
                ∇Np = shape_gradient(cv_p, q_point, jₚ)
                Np = shape_value(cv_p, q_point, jₚ)
                Kpp_ij = (m.k/m.ϕ) * ∇δNp ⋅ ∇Np * dΩ
                Lpp_ij = δNp*Np/m.K_liquid
                Ke[Iₚ,Jₚ] += Δt*Kpp_ij + Lpp_ij
                fext[Iₚ] += Lpp_ij*a_old[Jₚ]
            end
        end
    end
end

struct FEDomain{M,CV,SDH&lt;:SubDofHandler}
    material::M
    cellvalues::CV
    sdh::SDH
end

function doassemble!(K, f, domains::Vector{&lt;:FEDomain}, a_old, Δt)
    assembler = start_assemble(K, f)
    for domain in domains
        doassemble!(assembler, domain, a_old, Δt)
    end
end

function doassemble!(assembler, domain::FEDomain, a_old, Δt)
    material = domain.material
    cv = domain.cellvalues
    sdh = domain.sdh
    n = ndofs_per_cell(sdh)
    Ke = zeros(n,n)
    fe = zeros(n)
    ae_old = zeros(n)

    for cell in CellIterator(sdh)
        map!(i-&gt;a_old[i], ae_old, celldofs(cell)) # copy values from a_old to ae_old
        fill!(Ke, 0)
        fill!(fe, 0)
        element_routine!(Ke, fe, material, cv, cell, ae_old, Δt, sdh)
        assemble!(assembler, celldofs(cell), Ke, fe)
    end
end

function get_grid()
    # Import grid from abaqus mesh
    grid = get_ferrite_grid(joinpath(@__DIR__, &quot;porous_media_0p25.inp&quot;))

    # Create cellsets for each fieldhandler
    addcellset!(grid, &quot;solid3&quot;, intersect(getcellset(grid, &quot;solid&quot;), getcellset(grid, &quot;CPS3&quot;)))
    addcellset!(grid, &quot;solid4&quot;, intersect(getcellset(grid, &quot;solid&quot;), getcellset(grid, &quot;CPS4R&quot;)))
    addcellset!(grid, &quot;porous3&quot;, intersect(getcellset(grid, &quot;porous&quot;), getcellset(grid, &quot;CPS3&quot;)))
    addcellset!(grid, &quot;porous4&quot;, intersect(getcellset(grid, &quot;porous&quot;), getcellset(grid, &quot;CPS4R&quot;)))
    return grid
end

function setup_problem(;t_rise=0.1, p_max=100.0)

    grid = get_grid()

    # Setup the materials
    m_solid = Elastic(;E=20.e3, ν=0.3)
    m_porous = PoroElastic(;elastic=Elastic(;E=10e3, ν=0.3), K_liquid=15e3, k=5.0e-2, ϕ=0.8)

    # Setup the interpolation and integration rules
    dim=Ferrite.getdim(grid)
    ipu_quad = Lagrange{RefQuadrilateral,2}()^2
    ipu_tri  = Lagrange{RefTriangle,2}()^2
    ipp_quad = Lagrange{RefQuadrilateral,1}()
    ipp_tri  = Lagrange{RefTriangle,1}()

    qr_quad = QuadratureRule{RefQuadrilateral}(2)
    qr_tri  = QuadratureRule{RefTriangle}(2)

    # CellValues
    cvu_quad = CellValues(qr_quad, ipu_quad)
    cvu_tri = CellValues(qr_tri, ipu_tri)
    cvp_quad = CellValues(qr_quad, ipp_quad)
    cvp_tri = CellValues(qr_tri, ipp_tri)

    # Setup the DofHandler
    dh = DofHandler(grid)
    # Solid quads
    sdh_solid_quad = SubDofHandler(dh, getcellset(grid,&quot;solid4&quot;))
    add!(sdh_solid_quad, :u, ipu_quad)
    # Solid triangles
    sdh_solid_tri = SubDofHandler(dh, getcellset(grid,&quot;solid3&quot;))
    add!(sdh_solid_tri, :u, ipu_tri)
    # Porous quads
    sdh_porous_quad = SubDofHandler(dh, getcellset(grid, &quot;porous4&quot;))
    add!(sdh_porous_quad, :u, ipu_quad)
    add!(sdh_porous_quad, :p, ipp_quad)
    # Porous triangles
    sdh_porous_tri = SubDofHandler(dh, getcellset(grid, &quot;porous3&quot;))
    add!(sdh_porous_tri, :u, ipu_tri)
    add!(sdh_porous_tri, :p, ipp_tri)

    close!(dh)

    # Setup the domains
    domains = [FEDomain(m_solid, cvu_quad, sdh_solid_quad),
               FEDomain(m_solid, cvu_tri, sdh_solid_tri),
               FEDomain(m_porous, (cvu_quad, cvp_quad), sdh_porous_quad),
               FEDomain(m_porous, (cvu_tri, cvp_tri), sdh_porous_tri)
               ]

    # Add boundary conditions
    ch = ConstraintHandler(dh);
    add!(ch, Dirichlet(:u, getfaceset(grid, &quot;bottom&quot;), (x, t) -&gt; zero(Vec{2}), [1,2]))
    add!(ch, Dirichlet(:p, getfaceset(grid, &quot;bottom_p&quot;), (x, t) -&gt; 0.0))
    add!(ch, Dirichlet(:p, getfaceset(grid, &quot;top_p&quot;), (x, t) -&gt; p_max*clamp(t/t_rise,0,1)))
    close!(ch)

    return dh, ch, domains
end

function solve(dh, ch, domains; Δt=0.025, t_total=1.0)
    K = create_sparsity_pattern(dh);
    f = zeros(ndofs(dh))
    a = zeros(ndofs(dh))
    pvd = paraview_collection(&quot;porous_media.pvd&quot;);
    for (step, t) = enumerate(0:Δt:t_total)
        if t&gt;0
            doassemble!(K, f, domains, a, Δt)
            update!(ch, t)
            apply!(K, f, ch)
            a .= K\f
        end
        vtk_grid(&quot;porous_media-$step&quot;, dh) do vtk
            vtk_point_data(vtk, dh, a)
            vtk_save(vtk)
            pvd[step] = vtk
        end
    end
    vtk_save(pvd);
end

dh, ch, domains = setup_problem()
solve(dh, ch, domains)</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../topology_optimization/">« Topology optimization</a><a class="docs-footer-nextpage" href="../../topics/">Topic guide overview »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 29 June 2023 16:20">Thursday 29 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
